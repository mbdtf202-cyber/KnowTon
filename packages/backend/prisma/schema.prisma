generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String    @id @default(uuid())
  email             String?   @unique
  password          String?
  walletAddress     String?   @unique
  username          String?   @unique
  role              String    @default("user")
  isEmailVerified   Boolean   @default(false)
  emailVerifyToken  String?   @unique
  emailVerifyExpiry DateTime?
  resetToken        String?   @unique
  resetTokenExpiry  DateTime?
  lastLoginAt       DateTime?
  isActive          Boolean   @default(true)
  kycStatus         String    @default("none") // none, pending, approved, rejected
  kycLevel          Int       @default(0) // 0: none, 1: basic, 2: advanced
  kycProvider       String? // jumio, onfido, etc.
  kycTransactionId  String?   @unique
  kycVerifiedAt     DateTime?
  kycData           Json? // Store KYC verification data
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([email])
  @@index([walletAddress])
  @@index([emailVerifyToken])
  @@index([resetToken])
  @@index([kycStatus])
  @@index([kycTransactionId])
  @@map("users")
}

model Creator {
  id                    String              @id @default(uuid())
  walletAddress         String              @unique
  did                   String              @unique
  displayName           String
  bio                   String?
  avatar                String?
  website               String?
  social                Json?
  creatorType           String              @default("individual") // individual, institution, enterprise
  verificationStatus    String              @default("pending") // pending, approved, rejected
  verificationNote      String? // Admin notes for rejection/approval
  verifiedAt            DateTime?
  verifiedBy            String? // Admin user ID who verified
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  contents              Content[]
  portfolioItems        CreatorPortfolio[]

  @@index([walletAddress])
  @@index([verificationStatus])
  @@map("creators")
}

model CreatorPortfolio {
  id          String   @id @default(uuid())
  creatorId   String
  title       String
  description String?
  fileUrl     String // S3 or IPFS URL
  fileType    String // pdf, image, video, etc.
  fileSize    Int
  uploadedAt  DateTime @default(now())
  creator     Creator  @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([creatorId])
  @@map("creator_portfolio")
}

model Content {
  id             String   @id @default(uuid())
  creatorAddress String
  title          String
  description    String?
  category       String
  tags           String[]
  ipfsHash       String
  contentHash    String   @unique
  aiFingerprint  String
  fileType       String
  fileSize       Int
  fileName       String
  status         String   @default("uploaded")
  views          Int      @default(0)
  likes          Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  creator        Creator  @relation(fields: [creatorAddress], references: [walletAddress])

  @@index([creatorAddress])
  @@index([contentHash])
  @@index([aiFingerprint])
  @@index([category])
  @@map("contents")
}

model NFT {
  id              String   @id @default(uuid())
  tokenId         String   @unique
  contractAddress String
  creatorAddress  String
  ownerAddress    String
  contentId       String
  metadataUri     String
  royaltyPercent  Int
  price           String?
  status          String   @default("minted")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([tokenId])
  @@index([creatorAddress])
  @@index([ownerAddress])
  @@map("nfts")
}

model Transaction {
  id          String   @id @default(uuid())
  txHash      String   @unique
  type        String
  fromAddress String
  toAddress   String
  tokenId     String?
  amount      String
  status      String   @default("pending")
  blockNumber Int?
  gasUsed     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([txHash])
  @@index([fromAddress])
  @@index([toAddress])
  @@map("transactions")
}

model RoyaltyDistribution {
  id             String   @id @default(uuid())
  tokenId        String
  salePrice      String
  seller         String
  buyer          String
  distributions  Json
  txHash         String   @unique
  originalTxHash String
  status         String   @default("completed")
  createdAt      DateTime @default(now())

  @@index([tokenId])
  @@index([seller])
  @@index([buyer])
  @@map("royalty_distributions")
}

model Order {
  id           String    @id
  tokenId      String
  maker        String
  type         String
  price        String
  amount       Int
  filledAmount Int       @default(0)
  status       String    @default("OPEN")
  createdAt    DateTime  @default(now())
  expiresAt    DateTime?

  @@index([tokenId])
  @@index([maker])
  @@index([status])
  @@map("orders")
}

model Trade {
  id          String   @id @default(uuid())
  buyOrderId  String
  sellOrderId String
  tokenId     String
  buyer       String
  seller      String
  price       String
  amount      Int
  txHash      String   @unique
  createdAt   DateTime @default(now())

  @@index([tokenId])
  @@index([buyer])
  @@index([seller])
  @@index([txHash])
  @@map("trades")
}

model FractionalVault {
  id           String   @id @default(uuid())
  vaultId      String   @unique
  nftContract  String
  tokenId      String
  curator      String
  totalSupply  String
  name         String
  symbol       String
  reservePrice String
  status       String   @default("active")
  txHash       String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([vaultId])
  @@index([curator])
  @@index([nftContract, tokenId])
  @@map("fractional_vaults")
}

model Proposal {
  id              String   @id @default(uuid())
  proposalId      String   @unique
  proposer        String
  targets         String[]
  values          String[]
  calldatas       String[]
  description     String
  descriptionHash String
  status          String   @default("pending")
  txHash          String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  votes           Vote[]

  @@index([proposalId])
  @@index([proposer])
  @@index([status])
  @@map("proposals")
}

model Vote {
  id         String   @id @default(uuid())
  proposalId String
  voter      String
  support    Int
  reason     String?
  txHash     String
  createdAt  DateTime @default(now())
  proposal   Proposal @relation(fields: [proposalId], references: [proposalId])

  @@index([proposalId])
  @@index([voter])
  @@map("votes")
}

model Bond {
  id            String                @id @default(uuid())
  bondId        String                @unique
  ipnftId       String
  totalValue    String
  maturityDate  DateTime
  status        String                @default("ACTIVE")
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  tranches      Tranche[]
  investments   Investment[]
  distributions RevenueDistribution[]
  redemptions   Redemption[]

  @@index([bondId])
  @@index([ipnftId])
  @@map("bonds")
}

model Tranche {
  id         String @id @default(uuid())
  bondId     String
  trancheId  Int
  name       String
  priority   Int
  allocation String
  invested   String @default("0")
  apy        Float
  riskLevel  String
  bond       Bond   @relation(fields: [bondId], references: [bondId])

  @@unique([bondId, trancheId])
  @@index([bondId])
  @@map("tranches")
}

model Investment {
  id        String   @id @default(uuid())
  bondId    String
  trancheId Int
  investor  String
  amount    String
  txHash    String   @unique
  timestamp DateTime @default(now())
  bond      Bond     @relation(fields: [bondId], references: [bondId])

  @@index([bondId])
  @@index([investor])
  @@map("investments")
}

model RevenueDistribution {
  id        String   @id @default(uuid())
  bondId    String
  amount    String
  txHash    String   @unique
  timestamp DateTime @default(now())
  bond      Bond     @relation(fields: [bondId], references: [bondId])

  @@index([bondId])
  @@map("revenue_distributions")
}

model Redemption {
  id        String   @id @default(uuid())
  bondId    String
  trancheId Int
  investor  String
  txHash    String   @unique
  timestamp DateTime @default(now())
  bond      Bond     @relation(fields: [bondId], references: [bondId])

  @@index([bondId])
  @@index([investor])
  @@map("redemptions")
}

model Collateral {
  id          String   @id @default(uuid())
  userAddress String
  nftContract String
  tokenId     String
  valuation   String
  protocol    String
  txHash      String   @unique
  status      String   @default("ACTIVE")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userAddress])
  @@index([tokenId])
  @@map("collaterals")
}

model Loan {
  id          String   @id @default(uuid())
  userAddress String
  asset       String
  amount      String
  txHash      String   @unique
  status      String   @default("ACTIVE")
  borrowedAt  DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userAddress])
  @@index([status])
  @@map("loans")
}

model Repayment {
  id          String   @id @default(uuid())
  userAddress String
  asset       String
  amount      String
  txHash      String   @unique
  repaidAt    DateTime @default(now())

  @@index([userAddress])
  @@map("repayments")
}

model Upload {
  id                    String                  @id
  userId                String
  filename              String
  filetype              String
  filesize              BigInt
  fileHash              String?
  uploadOffset          BigInt                  @default(0)
  status                String                  @default("uploading") // uploading, validating, processing, completed, failed, rejected
  error                 String?
  metadata              Json?
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  completedAt           DateTime?
  plagiarismDetections  PlagiarismDetection[]

  @@index([userId])
  @@index([status])
  @@map("uploads")
}

model PlagiarismDetection {
  id                String                @id @default(uuid())
  uploadId          String
  contentUrl        String
  contentType       String // image, audio, video, text
  isPlagiarism      Boolean               @default(false)
  maxSimilarity     Float                 @default(0)
  threshold         Float                 @default(0.85)
  totalMatches      Int                   @default(0)
  similarContent    Json // Array of similar content items
  status            String                @default("detected") // detected, appealed, resolved, dismissed
  action            String? // warning, rejected, approved
  detectedAt        DateTime              @default(now())
  resolvedAt        DateTime?
  resolvedBy        String? // Admin user ID
  resolutionNote    String?
  upload            Upload                @relation(fields: [uploadId], references: [id], onDelete: Cascade)
  appeals           PlagiarismAppeal[]

  @@index([uploadId])
  @@index([status])
  @@index([isPlagiarism])
  @@map("plagiarism_detections")
}

model PlagiarismAppeal {
  id                    String              @id @default(uuid())
  detectionId           String
  userId                String
  reason                String
  evidence              Json? // URLs, documents, etc.
  status                String              @default("pending") // pending, approved, rejected
  submittedAt           DateTime            @default(now())
  reviewedAt            DateTime?
  reviewedBy            String? // Admin user ID
  reviewNote            String?
  detection             PlagiarismDetection @relation(fields: [detectionId], references: [id], onDelete: Cascade)

  @@index([detectionId])
  @@index([userId])
  @@index([status])
  @@map("plagiarism_appeals")
}

model Payment {
  id                    String              @id @default(uuid())
  userId                String
  contentId             String?
  amount                Decimal             @db.Decimal(20, 2)
  currency              String              @default("USD") // USD, EUR, CNY, JPY
  paymentMethod         String              // stripe, crypto, alipay, wechat
  stripePaymentIntentId String?             @unique
  stripeCustomerId      String?
  status                String              @default("pending") // pending, processing, succeeded, failed, canceled, refunded
  metadata              Json?
  installmentPlan       Json? // { months: 3, amountPerMonth: 33.33 }
  threeDSecureStatus    String? // required, succeeded, failed
  errorMessage          String?
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  completedAt           DateTime?
  refunds               Refund[]
  webhookEvents         WebhookEvent[]

  @@index([userId])
  @@index([contentId])
  @@index([status])
  @@index([stripePaymentIntentId])
  @@index([stripeCustomerId])
  @@map("payments")
}

model Refund {
  id                String              @id @default(uuid())
  paymentId         String
  amount            Decimal             @db.Decimal(20, 2)
  currency          String
  reason            String?
  status            String              @default("pending") // pending, succeeded, failed
  stripeRefundId    String?             @unique
  createdAt         DateTime            @default(now())
  processedAt       DateTime?
  payment           Payment             @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([status])
  @@map("refunds")
}

model WebhookEvent {
  id                String              @id @default(uuid())
  paymentId         String?
  eventType         String // payment_intent.succeeded, payment_intent.payment_failed, etc.
  stripeEventId     String              @unique
  data              Json
  processed         Boolean             @default(false)
  processedAt       DateTime?
  createdAt         DateTime            @default(now())
  payment           Payment?            @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  @@index([paymentId])
  @@index([eventType])
  @@index([processed])
  @@index([stripeEventId])
  @@map("webhook_events")
}
